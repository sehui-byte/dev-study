# 분할정복 알고리즘

### 이진탐색

- 정렬되어 있는 배열 기준으로 반으로 나누면서 데이터를 찾음
- 시간복잡도 :
  - N개의 데이터가 있을 때 탐색을 하면 N, N/2, N/4 ... 1 실행된다. 탐색 횟수를 K라고 하면  2^K = N → K = log2N
  - O(logN)
  - T(n) = T(n/2) + θ(1) → O(logN)

### 합병정렬 알고리즘

- 중앙을 중심으로 두개씩 트리구조로 나누고 병합할 때 각 노드들을 작은 수 부터 배치
- 시간복잡도 :
  - N개 데이터가 있을 때 N, N/2, N/4 ... 1        2*(N/2), 4(N/4), 8(N/8)... →
  - O(nlog(2)n)
  - T(n) = 2T(n/2) + θ(n) → O(nlogn)
  - 합병 함수 : θ(n)
- 공간복잡도 : O(n)

### 퀵정렬

- 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법
- 합병정렬과는 달리 리스트를 비균등하게 분할한다.
- 분할 : 비균등하게 2개의 부분배열로 분할
- 정복 : 부분 배열을 정렬. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용
- 결합 : 정렬된 부분 배열들을 하나의 배열에 합병한다.
- 가장 왼쪽값을 피벗으로 잡고 피벗의 오른쪽으로는 큰 피벗보다 큰 수가 있는지 반대 끝에서는 피벗보다 작은수가 있는지 체크하고 있다면 큰 수와 작은 수의 위치를 바꾼다.
- 그리고 left와 right가 교차되면 교차지점에  작은 수와 피벗의 위치를 바꾼다.
- 그리고 피벗을 기준으로 좌우로 부분배열로 나눈뒤 피벗을 정하고 같은 방법을 취한다. (이미 피벗을 기준으로 작은 수들과 큰 수들을 집합 시켰으므로)
- 시간복잡도 :  N = 2^K   →   K = log(2)N   → O(Nlog(2)N)
- 최악 : T(n) = T(n-1) + θ(n) → O(n^2)
- 최선 : T(n) = 2T(n/2) + θ(n) → O(nlogn)
- 평균 : O(nlogn)

### 선택문제

- 오름차순으로 정렬 후 작은 수를 찾는 방법(O(nlogn))을 보완
- 퀵정렬과 마찬가지로 피벗을 기준으로 작은 수와 큰 수를 나눈후 한쪽 부분배열을 날린다.
- 그리고 남은 배열에서 크기로 정렬하고 몇번째로 작은지 찾을 수 있다.
- 시간복잡도 :
- 최솟값 or 최댓값 찾기 : 최소 (n-1) 번 비교 → O(n)
- 최솟값, 최댓값 모두 찾기 :  3n/2-2번의 비교
- i번째로 작은 원소 찾기
- 퀵 정렬 분할함수를 이용하는 경우 - 최악 : O(n^2), 평균 O(n)
- [n/5]개의 그룹에 대한 중간값을 구하고, 이 중간값들의 중간값을 다시 구하여 피벗으로 지정해서 배열을 분할하는 경우 → 최악 : O(n), 평균 O(n)





---

# 동적프로그래밍

### 피보나치수열

- f(n-1) + f(n-2), n≥ 2
- 1                     , n =1
- 0                     , n=0
- 시간복잡도 : O(n)

### 연쇄행렬곱셈문제

- (M1M2)M3 = (3*2*4) + (3*4*1) = 36번
- M1(M2M3) = (2*4*1) + (3*2*1) = 14번
- 시간복잡도 : O(n^3) = O(n(n-1)(n+1)/6)

### 스트링 편집 거리 문제

- 두 문자열의 유사도를 판단하는 알고리듬
- abcdef와 azced를 비교할때 각각 행과 열로 비교하고 공집합을 0으로 둬서 삽입,삭제,수정에 대해 1씩 변화 시킨다.
- 두 문자가 같으면 왼쪽위 값을 쓰고
- 두 문자가 다르면 왼쪽, 왼쪽위, 위 중 가장 작은 숫자에 +1시킴
- 시간복잡도 : O(nm)

### 모든 정점 간의 최단 경로

- 플로이드 알고리즘
- 각 정점에 대해서 행렬로 표시하고 간선화살표가 없을경우 무한대로 표시, 그리고 정점을 걸쳐서 갈경우 각 간선의 거리를 더함
- 시간복잡도 : O(|V|^3)

### 저울 문제

- M:무게, n=추의 개수
- 시간복잡도 : O(Mn)



---

# 욕심쟁이 알고리즘

### 동전 거스름돈 문제

- 동전 거스름돈 문제는 동적알고리즘으로 최적해를 구하는게 효과적이다.
- 임의로 주어지는 동전에 대해서는 욕심쟁이 알고리즘은 적합하지 않음
- 시간복잡도  : O(n)

### 배낭 문제

- 물체를 쪼갠다는 가정하에 부분배낭 문제로 해결
- 시간복잡도 : O(n), 정렬을 고려하면 O(nlogn)
- 물체를 쪼갤 수 없는 0/1배낭문제는 적합하지 않음

### 최소 신장 트리

- 크루스칼
  - 정점끼리 연결되어있는 각 간선들을 크기가 작은 수 부터 나열한 뒤 작은 간선 부터 다시 이어붙힘.
  - 이미 정점간의 연결 되어있다면 나중 간선은 삭제함
  - 시간 복잡도 : O(|E|log|E|)
- 프림 알고리즘
  - 한 정점을 중심으로 다음 정점까지 연결될 수 있는 간선들을 비교하여 작은 값의 간선 부터 하나씩 연결함
  - 시간복잡도 : 그래프O(V^2), 인접리스트이로 그래프를 구현하고 힙을 사용하면 O((|V|+|E|)log|V|)

### 최단 경로

- 데이크스트라
  - 시간복잡도 : 그래프O(V^2), 인접리스트이로 그래프를 구현하고 힙을 사용하면 O((|V|+|E|)log|V|)

### 작업 스케줄링 문제

- 가장 적은 개수의 기계를 사용해서 작업 간의 충돌이 발생하지 않도록 모든 작업을 기계에 할당하는 문제
- 작업이 충돌나면 새 기계에 작업을 할당하는 구조
- 시작시간이 빠른 작업부터 처리하기 위해서 오름차순으로 정렬
- 시간복잡도 : O(nlogn)

### 작업 선택 문제

- 한 기계에서 여러작업을 수행할 때 충돌나는 작업은 삭제하는 문제
- 완료시간이 빠른작업부터 처리하기 위해서 오름차순으로 정렬
- 시간복잡도 : O(nlogn)

### 호프만 코딩

- 문자열을 압축하는 방법으로 문자의 빈도수를 이용하여 빈도수가 높으면 짧은 코드, 짧으면 긴 코드로 변환한다.
- 문자의 출현 빈도수를 계산하고
- 각 문자의 빈도수를 이용하여 허프만 트리를 생성하여 각 문자에 이진코드를 부여한다ㅡ
- 주어진 텍스트의 각 문자를 코드로 변환하여 압축된 텍스트를 생성한다.
- 시간복잡도 : O(nlogn+m)



# 정렬 알고리즘

### 버블정렬

- 오름차순 정렬시 index, index+1을 비교하여 자리를 변경해서 배열의 길이만큼 반복
- 시간복잡도 : O(n^2)
- 안정적, 제자리

### 선택정렬

- 오름차순 정렬시 처음값과 두번째 값부터 비교 후 최솟값을 처음에 두고 두번째 값과 세번째 값부터 비교후 최솟값을 두번째에 위치시킨다. 이를 반복
- 시간복잡도 : O(n^2)
- 불안정적, 제자리

### 삽입정렬

- 카드정렬
- 각 자리마다 자리부터 첫번째까지 비교하면서 정렬
- 시간복잡도 : 최악,평균 : O(n^2) 최선 : O(n)
- 안정적, 제자리

### 셸정렬

- 삽입정렬이 빠른것에 대한 보완
- 간격의 값 = 정렬할 값의 수 / 2
- 간격의 값 = 간격의 값/2 → 기존 간격의 값이 짝수 일 경우 + 1 (홀수가 좋다)
- 80 50 70 10 60 20 40 30
- 60 20 40 10 80 50 70 30 (8*1/2 =4)
- 40 10 60 20 70 30 80 50 (4*1/2 =2)
- 10 20 30 40 50 60 70 80 (2*1/2 =1)
- 시간 복잡도 : O(n), O(n^1.5), O(n^2)
- 불안정적, 제자리

### 기수 정렬

- 비교연산을 하지않음
- 빠르지만 기수정렬테이블 만큼의 메모리가 하나 더 필요함
- 일의 자리로 각각의 부분배열로 만든다.
- 십의자리로 각각의 부분배열에서 데이터를 넣는다.
- 시간복잡도 : O(n)
- 자리수가 고정되어있어서 안정성이 있는 정렬 방식, 제자리 방식 아님