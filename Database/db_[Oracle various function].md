###### 이번주의 주제 : 오라클에서 지원하는 다양한 기능들(8 이상)



##### 목차는 다음과 같습니다.

#### 1.데이터 복구와 삭제 및 이관

#### 2.오라클의 스케줄러

#### 3.계층적 쿼리

#### 4.오라클 집계함수



### 1.데이터 복구와 삭제 및  이관 내용(10g 부터)

- 1.휴지통에 있는 데이터 조회하기.
  기능 : 휴지통에 있는 데이터를 조회합니다. 윈도우 컴퓨터 자체의 휴지통 이라고 생각하면 됩니다.
  사용법 : RECYCLEBIN 을 사용합니다.

  

- 2.테이블 복구하기.
  기능 : 테이블 이름을 기준으로 삼아 복구를 할 수 있습니다.
  사용법 : FLASHBACK 을 사용합니다.



- 3.복구불가 영구히 삭제.
  기능 : 휴지통에 쌓이지 않고 영구히 지웁니다.
  사용법 : TABLENAME PURGE

  

- 4.휴지통 비우기.
  기능 : 복구불가가 아닌 일반적으로 테이블을 지운 것의 다음 스텝입니다.
  사용법 : PURGE RECYCLEBIN 

--------------------------------데이터 이관의 기능-------------------------------------------------



- 1.테이블 복사하기.
  기능 : 스키마와 테이블 복사입니다.
  사용법 : TO TABLE 과 FROM TABLE을 구분지어서 생성, 조회 명령문을 짭니다.

  

- 2.테이블 구조만 복사하기.
  기능 : 테이블 구조 복사입니다.
  사용법 : FROM TABLE 대상의 WHERE 조건에서 1=2 를 사용합니다.

  

- 3.테이블은 있고 데이터만 복사하기.
  기능 : 테이블에서 데이터를 꺼내 옮깁니다. 주로 프로시저에서 자동 데이터 이관 처리할 때
        사용하게 됩니다.
  사용법 : INSERT INTO ~ SELECT 형태입니다.

  

- 4.테이블은 있고 데이터만 복사하되, 테이블 구조가 다를 때(3번과 다른 점임.)
  기능 : 3번과 같습니다.
  사용법 : 테이블 구조가 다르므로, 3번과는 달리 컬럼명을 수작업으로 해주어야 합니다.



--------------------데이터 복구 및 삭제의 쿼리 ----------------------------

- 1번 : 휴지통 테이블 조회
  SELECT * FROM RECYCLEBIN;
  --> OBJECT_NAME 부터 테이블 이름과 테이블 유형 생성 삭제시간 등의 데이터를 보여줍니다.
      --> 복구할 수 있는지 없는지도 CAN_UNDROP 이란 컬럼으로 보여줍니다. 

  

- --2번 : 테이블 복구하기
  FLASHBACK TABLE EMP TO BEFORE DROP;
  --> 1번에서 언급한 RECYCLEBIN 에 해당 테이블 객체가 존재해야 가능합니다.
      --> 만약 작업이 수행되지 않는다면, 테이블 내용이 RECYCLEBIN에 없는 것입니다.

  

- --3번 : 복구 불가 영구 삭제
  DROP TABLE TABLENAME PURGE;
  --> 해당 SQL 문은 1번이 수행되기 전에(즉, 휴지통에 보내기 전에) 하는 쿼리입니다.
      --> 하지만 휴지통에 보내지 않고 바로 영구 삭제를 하게되면 테이블 복구를 절대 할 수 없으므로
      --> 사용시 주의해야 합니다.

  

- --4번 : 휴지통 비우기
  PURGE RECYCLEBIN
  --> 휴지통 비우기 SQL문은 가급적 하지 않는게 좋습니다. 결과론적으로 보면, 최종 기능은 3번의 쿼리문과 같습니다.
      --> 따라서 DB의 파티션 용량이 부족하거나, CPU 부하가 심하다거나 자원이 급히 필요한 경우일 때 제외하고는
      --> 삭제했던 데이터가 필요없다고 확신하는 경우만 사용합니다.

  


###### 주의할 점 : 테이블 복구시, index 등의 기능도 복구가 되지만, 기존 이름과 다르게 복구가 됩니다. 해당 모든 기능들은 오라클 10g 부터 지원을 합니다. 





------------------------데이터 이관의 쿼리 -------------------------------

###### TO TABLE : 목적지 테이블로 정의합니다.
###### TABLE-1 : 모수 데이터를 꺼낼 테이블로 정의합니다.



- 1.테이블 복사하기
  CREATE TABLE (TO TABLE) AS
  SELECT * FROM (TABLE-1) WHERE 
  --> 기본 구조는 이렇게 되며 TO TABLE이란 위에 기재한 바와 같이 목적지 테이블에 해당합니다.
      --> 풀어 해석하면 WHERE 조건을 고려하여 TABLE-1 을 조회한 데이터를 TO TABLE에 생성합니다.
      --> 이 때, 스키마 정보도 같이 따라옵니다.

  

- --2.테이블 구조만 복사하기
  CREATE TABLE (TO TABLE) AS
  SELECT * FROM (TABLE-1) WHERE 1=2 --(1=2 라는 FALSE 조건을 걸어줍니다.)
  --> WHERE 1=1 조건이 오게되면 참으로 수행을 하기 때문에, 데이터가 같이 들어가게 될 것입니다.
      --> 따라서 1=2를 걸고 구조만 복사해서 테이블을 만드는 형태입니다.

  

- --3.테이블은 있고 데이터만 복사하기
  INSERT INTO (TO TABLE)
  SELECT * FROM (TABLE-1) WHERE 
  --> 흔히 데이터 자동 이관처리를 할 수 있는 프로시저의 기능에 넣어두는 구문입니다.
      --> 프로시저 작동의 자동화 프로세스가 곁들여 진다면, 업무에서의 인터페이스 처리시 수작업으로
      --> 데이터 작업을 할 수고를 덜어주는 기능입니다.

  

- --4.테이블 있고 데이터만 복사하기(3번과 달리 테이블 구조가 다를 때)
  INSERT INTO (TO TABLE) (COLUMN1, COLUMN2, COLUMN3, , , ,)
  SELECT (COLUMN1, COLUMN2, COLUMN3 , , , ) FROM (TABLE-1) WHERE
  --> 실제로 3번 보다는 4번의 과정이 프로시저의 기능 구현에 더 자주 쓰입니다.
      --> 이유는 주로 쓰이는 현업의 인터페이스 처리시 각 시스템 별로 테이블 구조가 일치할 수가 없기 때문에,
      --> 테이블의 구조가 다르다면 3번과는 달리 4번의 방법으로 인터페이스 처리 진행을 합니다.



######  해당 방법은 규칙이 있습니다.
        1.데이터의 테이블 이관시 매핑이 되어 데이터가 들어가는 컬럼의 개수를 맞춰주는 것.
            >> 기본적인 INSERT 문의 컬럼 매핑 수가 같아야 함과 일치합니다.
        2.컬럼의 속성 비교를 주의할 것.
            >> 가령 A 라는 데이터를 B2B 통신으로 전달 받는다고 할 때, 컬럼 제약이 데이터 송신 처리시
               걸림돌이 될 수 있습니다. 따라서 인터페이스 처리 협업을 할 때 해당 사항은 반드시 오가야 하는
               내용입니다. 
            >> 만일 데이터 가공이 필요할 때에는 프로시저에 가공 기능을 넣어서 처리할 수도 있습니다.



### 2.오라클의 스케줄러

- 1)오라클의 잡과 스케줄러
  : DB를 운영하다 보면 하루에 한번씩 운영서버의 데이터를 개발서버에 데이터를 넣어주거나 하는 작업을
  할 수가 있습니다. 이렇게 일정한 주기의 작업을 디비에서는 JOB(잡) 이라고 합니다.
  이런 주기적인 행위를 수행하는 방법은 스케줄러를 활용하는 방법이 있습니다.

  

- 2)오라클의 스케줄러(DBMS_SCHEDULER)
  : 기존에는 주기적인 작업을 잡 패키지 라는 것을 활용해 작업을 했지만, 다양한 문제점으로 인해
  오라클 10g 부터는 새로운 스케줄러 패키지인 DBMS_SCHEDULER 라는 패키지가 추가 되었습니다.
  최근에는 해당 패키지를 통해서 주기적인 JOB을 처리합니다.

  

** 참고로 관리자 계정이 아닌 경우에는 스케줄러 사용의 권한이 없을 수 있습니다.
GRANT CREATE ANY JOB TO USERNAME; 을 통해서 권한 먼저 있는지 확인을 하고 하는 것이 좋습니다.
--> 잡 생성 모든 권한 부여.



- 3) 오라클의 스케줄러 사용법 : 잡 객체

  BEGIN
      DBMS_SCHEDULER.CREATE_JOB
      (
          JOB_NAME => 'EX_JOB',   -- JOB 이름
          JOB_TYPE => 'STORED_PROCEDURE', -- JOB 유형
          JOB_ACTION => 'EX_PROC',    -- 프로시저 이름
          REPEAT_INTERVAL => 'FREQ=MINUTELY; INTERVAL =1',    -- 1분에 1번이라는 뜻
          COMMENTS => '프로시저 호출 및 실행'
      );
  END;
  --> 쿼리 해석을 하자면, EX_JOB 이라는 이름의 JOB이 EX_PROC 라는 프로시저를 1분에 1번씩
  --> 실행시키는 의미로 됩니다.



- 4)잡 생성 내역 확인
  SELECT JOB_NAME, JOB_TYPE, JOB_ACTION, REPEAT_INTERVAL, ENABLED, AUTO_DROP,
          STATE, COMMENTS
  FROM USER_SCHEDULER_JOBS
  --> 쿼리의 해석 : 잡을 생성한 전체목록은 USER_SCHEDULER_JOBS 라는 테이블에 저장이 됩니다.

  

- 5)잡의 실행 및 실행로그 확인
  실행)
  BEGIN
      DBMS_SCHEDULER.ENABLE ('EX_JOB');
  END;
  --> 잡을 처음 생성하면 ENABLED = FALSE 상태로 스케줄러_잡 테이블에 존재합니다.
  --> 잡을 활성화 시키려면 위의 코드를 1회 이상 실행시켜서 잡의 ENABLED 값을 TRUE로 바꾸어야 합니다.
  --> 한 번 이상 실행시키고 나면 위에 기술한 4번 내용의 쿼리를 다시 조회 했을 경우, ENABLED = TRUE, AUTO_DROP = TRUE 값으로 바뀌게 됩니다.

  

- 6)잡 객체 실행로그 확인하기
  SELECT * FROM USER_SCHEDULER_JOB_LOG;
  --> 로그 조회시 자신이 스케줄링을 설정한 시간대에 맞춰 돌기 때문에, 생성하고 난 뒤의 ROW 값은 스케줄링 된 시간대 만큼
  --> 해당 조회문의 결과에 모두 표시됩니다.



### 3.계층적 쿼리

- 1.계층적 쿼리란?
  : 계층형 구조는 상하 수직관계의 트리형태 구조로 이루어진 형태를 말합니다.
  예를 들자면 특정회사의 부서, 특정학교의 학과등이 있습니다. 계층형 쿼리는 테이블에 저장된 데이터를 계층형 구조로 반환하는 쿼리를 말합니다.
  : 오라클에서의 계층형 쿼리는 START WITH ... CONNECT BY 절로 생성할 수 있으며 계층형 정보를 표현하기 위한 목적으로 오라클 8부터 지원되었습니다.

  

- 2.수행순서
  : START WITH 절에 시작 조건이 걸린 것을 찾습니다.
  : CONNECT BY 절에 연결된 조건을 찾습니다.



- 3)계층형 쿼리 START WITH ... CONNECT BY 사용법

  - 먼저 계층적 구조를 이루도록 하는 쿼리를 짭니다.
    -- 총괄부 > 모바일개발센터 > 쇼핑몰(모바일) > 전산지원팀 
    -- 총괄부 > 웹개발센터 > 외주 SI, 쇼핑몰 > 구축1팀, 구축2팀
    -- 총괄부 > 시스템개발센터 > ERP시스템 

    

  - CREATE TABLE DEP (
         DEP_CD NUMBER NOT NULL, -- 부서코드
         PARENT_CD NUMBER, -- 상위부서 코드
         DEPT_NAME VARCHAR2(100) NOT NULL, -- 부서이름
         PRIMARY KEY (DEP_CD)
    );

    

  - INSERT INTO DEP VALUES ( 101, NULL, '총괄개발부');
    INSERT INTO DEP VALUES ( 102, 101, '모바일개발센터');
    INSERT INTO DEP VALUES ( 103, 101, '웹개발센터');
    INSERT INTO DEP VALUES ( 104, 101, '시스템개발센터');

    INSERT INTO DEP VALUES ( 105, 102, '쇼핑몰(모바일)');
    INSERT INTO DEP VALUES ( 106, 103, '외주SI');
    INSERT INTO DEP VALUES ( 107, 103, '쇼핑몰');
    INSERT INTO DEP VALUES ( 108, 105, '전산지원팀');
    INSERT INTO DEP VALUES ( 109, 106, '구축1팀');
    INSERT INTO DEP VALUES ( 100, 106, '구축2팀');
    INSERT INTO DEP VALUES ( 111, 104, 'ERP시스템');

    > > 값을 넣어줍니다.

    

  - 조회 문법

    SELECT [COLUMN] ...
    FROM [TABLE]
    WHERE [조건]
    START WITH [최상위 조건]
    CONNECT BY [NOCYCLE][PIOR 계층형 구조 조건];
    --> START WITH 조건에 계층형 구조의 최상위 계층의 로우를 식별하는 조건을 넣습니다. 
    --> 처음 스캔을 시작하게 되는 조건을 걸어줍니다.
    --> CONNECT BY조건에서는 계층형 구조가 어떤식으로 START WITH의 값과 연결되는지 표현해주면 됩니다. 
     --> 연결의 표현을 토대로, CONNECT BY는 START WITH의 데이터와 연결된 ROW를 반복적으로 찾아갑니다.

    SELECT DEPT_NAME, DEP_CD, PARENT_CD,
    LEVEL
    FROM DEP 
    START WITH PARENT_CD IS NULL --최상위노드 설정,
    CONNECT BY PRIOR DEP_CD = PARENT_CD;--부모노드와 자식노드 연결
    --> 부서코드(DEP_CD)에 상위부서코드(PARENT_CD)를 가지고 있으므로 DEP_CD = PARENT_CD로 표현하였습니다.



### 4.오라클의 집계함수

- 1.집계함수란?

>> 여러 행 또는 테이블 전체 행으로부터 하나의 결과값을 반환하는 함수를 뜻합니다.
>> GROUP BY 절을 이용하여 그룹화, HAVING 절을 이요하여 그룹에 대한 조건 비교가 가능합니다.
>> 집계함수는 MULL에 대한 체크를 수행하지 않으므로, NULL 값을 포함한 ROW들을 불러옵니다.



- 2.기본 사용법

>> SELECT  
>> FUNCTION(column) FROM TABLENAME WHERE [조건]; -- 조건에도 기재가 필요할 경우 함수 기능을 가술합니다.



- 3.예제

  - SELECT COUNT(*) MENUDATE FROM KOSMENU;
    --> 단순히 카운트의 (* * )  쿼리는 NULL도 반환한다고 알려져 있다고 합니다. 
    --> COUNT(컬럼이름) 을 입력하게 되면 * 범위를 세는게 아닌 값이 있는 ROW만 조회해서 불러옵니다.
    --> 쿼리의 속도 개선은 매우 중요한 사항입니다.

    

  - SELECT SUM(PRICE) FROM RECEIPT;
    --> SUM은 합계를 나타내는 함수이므로 컬럼 반환 타입을 NUMBER가 되야합니다.

    

  - SELECT MAX(MENUDATE) FROM RECEIPT;  -- 컬럼의 전체 ROW중 가장 큰 값 조회합니다.
    SELECT MIN(MENUDATE) FROM RECEIPT;  -- 컬럼의 전체 ROW중 가장 작은 값 조회합니다. 

    

  - SELECT AVG(PRICE) FROM RECEIPT;     -- 검색된 행 중에서 평균 값을 반환합니다.