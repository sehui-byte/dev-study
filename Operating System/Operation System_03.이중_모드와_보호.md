---
title: 이중 모드와 보호
---

# 03.이중 모드와 보호

> 하나의 컴퓨터를 여러명 혹은 여러 프로그램을 사용하다 다른 프로그램이 영향을 받는 경우는 매우 위험하다. 이러한 문제를 해결하기 위해 **치명적인 명령어**의 요청을 막는 **이중 모드**가 생겨나게 되었다.

---

## 1) 이중모드

- 컴퓨터를 사용하는 모드를 둘로 나누는 것
  - 사용자 모드(User mode)
    - 일반적인 사용자가 사용 가능한 모드
    - 시스템에 해를 끼치지 않는 선에서 컴퓨터를 제어할 수 있음
  - 관리자 모드(Supervisor mode)
    - 일반적인 사용자가 사용할 수 없는 모드
    - 시스템에 치명적인 영향을 줄 수 있는 제어 가능
    - 시스템 모드, 모니터 모드, 특권 모드, 커널 모드라고도 함
- 이중 모드는 CPU에 있는 레지스터의 비트를 활용해서 나타낸다
  - flag로 나타낸다.
    - 레지스터의 비트가 `0`인 경우 → 관리자 모드
    - 레지스터의 비트가 `1`인 경우 → 사용자 모드
- 만약 사용자 모드에서 잘못된 명령어를 입력할 경우 해당 프로그램을 종료할 수도 있다.
- 사용자가 하드웨어의 자원에 접근하는 것은 매우 위험한 동작이기 때문에, 이러한 경우는 **관리자 모드로 전환하여 운영체제**에서 처리한다.

  - 사용자가 프로그램을 실행 중에 **HDD에 접근할 필요**가 있을 시, **소프트웨어 인터럽트**를 발생시켜 해당 동작을 운영체제에 위임하도록 한다.
  - 하드웨어 관련 로직 수행하기 위해 운영체제는 **시스템 콜**을 제공한다.
    - 일반적인 언어에서 아용하는 IO 관련 함수들이 바로 시스템 콜
  - 해당 과정을 자세히 살펴보면 아래와 같다.

    1. 하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)
    2. CPU에서 모드 플래그를 **관리자 모드**로 수정 (사용자 모드 → 관리자 모드 전환)
    3. 해당 하드웨어의 인터럽트 서비스 루틴(ISR)로 이동 (관리자 모드)
    4. 인터럽트 처리 (관리자 모드)
    5. 인터럽츠 처리 완료 후, CPU의 모드를 다시 **사용자 모드**로 변환 (사용자 모드)
    6. 기존 프로그램의 위치로 복귀후 다음 로직을 처리 (사용자 모드)

    ![__](https://user-images.githubusercontent.com/60249222/121777272-32253c00-cbcc-11eb-96ee-2c4ba8a11c9b.png)

    특정 함수(시스템 콜)은 관리자 모드(커널 모드)에서 진행한다. 대부분의 CPU는 이중 모드를 지원한다.

## 2) 하드웨어 보호

- 이중 모드는 운영체제의 기능 중 보호에 해당한다. 운영체제가 보호하는 대상은 입출력 장치, 메모리, CPU가 존재한다.

### 2-1) 입출력 장치 보호

- A, B 프로그램이 서로 입출력 장치에 접근하려고 할 경우, 이를 통제하는 기능을 수행
- 운영체제가 수행할 경우 해당 입출력 명령을 특권 명령으로 설정
  - A, B 두 프로그램이 프린터에 접근하려고 할 경우
    - in, out 과 같은 **입출력 명령을 특권 명령**으로 설정 → 소프트웨어 인터럽트 발생
    - A, B 두 프로그램 다 프린터에 접근(in, out 명령어를 수행)하려고 할 때, 운영체제가 내부에서 순서를 정해 혼선을 막는다.

### 2-2) 메모리 보호

- 메모리에는 다양한 프로그램이 존재한다. 하나의 프로그램이 다른 프로그램 메모리 영역을 침범하는 것은 치명적인 오류를 발생할 수 있다.
- 이를 방지하기 위해 MMU(Memory Management Unit)이 CPU와 Memory 사이에 위치한다.

  ![__ 1](https://user-images.githubusercontent.com/60249222/121777299-4701cf80-cbcc-11eb-9e3b-4868186f0f03.png)

  CPU - MMU - Memory의 관계

- MMU는 Base와 LImit라는 레지스터를 통해서 해당 프로그램의 메모리 주소(Base ~ Limit)를 저장한다.
- CPU는 Memory에 address bus를 보내는데, MMU가 address bus의 주소값을 확인하여, 해당 프로그램의 메모리 주소에 속한 address bus만 통과시킨다.
- 만약 주소 범위 밖의 address bus가 들어온다면, MMU에서 내부 인터럽트를 발생시켜 CPU가 해당 프로그램을 강제종료하도록 시킨다. → Segment violation

### 2-3) CPU 보호

- 하나의 프로그램이 CPU를 독점할 경우 → 다른 프로그램은 CPU를 사용할 수 없음
  - 무한 반복되는 경우
- 이를 해결하기 위해 **Timer를 두어 일정 시간이 지나면 타이머 인터럽트**를 발생시킨다.
- 타이머 인터럽트를 통해서 CPU는 ISR을 실행시킨다. ISR을 통해 각 프로그램의 CPU 점유 시간을 측정하여 적절하게 분배되도록 조정한다.
  - 하나의 프로그램의 CPU 점유 시간이 비정상적으로 높다면, ISR은 강제적으로 다른 프로그램으로 CPU를 전환시킬 수 있다.

---

_참고문헌_

- 운영체제 KOCW 양희재 교수님 강의(youtube) <[https://www.youtube.com/channel/UCvC5uyGB_oVtTZU15SFkqWg](https://www.youtube.com/channel/UCvC5uyGB_oVtTZU15SFkqWg)>
- codemcd님의 정리 자료 <[https://velog.io/@codemcd/운영체제OS-3.-이중모드와-보호](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-3.-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8)>
