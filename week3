###### 이번주 주제는 쿼리튜닝 및 모니터링 쿼리입니다.



###### 목차는 다음과 같습니다.

###### 1)쿼리튜닝

###### 2)모니터링 쿼리





###### 1.쿼리튜닝 이란 무엇인가?
: 쿼리를 효율적으로 실행할 수 있게 만드는 optimization 개념입니다.
개발자라면 옵티마이저가 실행계획을 생성할 때, 최대한도로 성능을 발휘할 수 있도록  불필요한 로직을 타지 않게 쿼리를 작성해야하는 능력을 갖주는게 좋다고 생각합니다. 같은 결과를 산출하는 쿼리는 여러 가지 형태로 작성될 수 있으므로, 개발자는 SQL 문장 단에서 최대한 효율적인 문장을 작성해야 합니다.
"쿼리를 이렇게 작성하면 좋은 성능을 발휘한다" 라는 개념을 아래의 가이드를 통해 소개하겠습니다.



- 가이드 1)가급적 WHERE 조건에서는 지정한 인덱스 컬럼을 모두 사용한다.
   - 인덱스를 만들어 놓더라도 where 조건을 어떻게 명시하느냐에 따라 옵티마이저가 인덱스를
        사용하기도 하고 그렇지 않을 수도 있습니다.

   - 하지만 인덱스를 대량으로 달고 where 에다 붙여버리면 그만큼 또 읽는 시간이 걸리기 때문에,
        full scane 을 피해 읽어주는 인덱스라고 해도 효율적으로 최소한의 인덱스를 유지하는 것이 쿼리 다루기에 효율적입니다.

        

   - 보통 인덱스를 거는 조건을 고려하는 사항으로 카디널리티라는 지표가 있습니다. row 값들의 중복도가 낮으면 카디널리티 수치가 높다고 할 수 있고,
        중복도가 높은 로우 값은 카디널리티가 낮다고 표현합니다. 하지만 카디널리티는 상대적인 관계로 이해해야 합니다.

         - id / name / location -- 컬럼

              0 / lee / seoul

              1 / park / pusan

              2 / choi / seoul

              3 / park / seoul

              4 / kim / seoul

              5 / bae / incheon

              6 / ahn / seoul

              7 / lee / seoul

              8 / lee / seoul

              9 / kim / seoul

              - 위와 같은 테이블의 값들이 있다고 할 때, id의 경우 전체 10건의 로우에 대해 중복된 값이 없으므로(주민등록번호처럼 컬럼이 unique한 값들로 이루어져 있으므로) 카디널리티가 ‘높다’ 라고 표현할 수 있습니다.

                name의 경우 distinct 값이 6건이므로 (lee, park, choi, kim, bae, ahm) ‘id컬럼보다는 카디널리티가 낮다’ 로 해석 할 수가 있겠고,

                location의 경우 distinct 값이 3건밖에 없으므로 (seoul, pusan, incheon) 카디널리티가 ‘제일 낮다’ 라고 해석을 할 수 있습니다.

                - 세부사항) distinct 값이 많다는건 중복도가 낮다는 의미로 보면 된다. id 컬럼의 경우 distinct 값이 10건이다.

                  users 테이블의 컬럼간 distinct 값의 차이를 보자면 `id(10건) > name(6건) > location(3건)` 이다

                  즉, distinct 값이 많으면 중복도가 낮다 = 카디널리티가 높다고 생각해도 된다.

                

         - 앞서 설명드린 바와 같이 인덱스의 고려사항으로 카디널리티 라는 지표는 중요하게 여겨집니다. 그러나 인덱스의 목적은 중복도가 낮은 데이터들을 산출해내는 것이므로, 카디널리티가 높은 row 값들을 인덱스로 거는 것이 쿼리튜닝에 유리합니다.

              

	            <인덱스 사용 상세설명>
	            - 예를 들어서 A와 B라는 컬럼의 인덱스를 만들었는데, WHERE 조건에서 A컬럼만 사용한다면 인덱스를 타지 않고
	              full scan을 하기 때문에 그만큼 오래걸린다.
	
	              - 쿼리 예시) contract 라는 테이블이 있다.
	                     contract_no, contract_rev 컬럼이 con_no_IDX 인덱스로 만들어져 있을 때,
	                     아래와 같은 쿼리는 인덱스를 타지 않고 FULL SCAN을 한다.
	
	                인덱스 없는 쿼리)
	                         SELECT *
	                         FROM CONTRACT 
	                         WHERE CONTRACT REV = '1'
	
	                인덱스 있는 쿼리)
	                         SELECT *
	                         FROM CONTRACT
	                         WHERE CONTRACT_NO = '10000'
	                         AND CONTRACT_REV = '1'
	               
	            * 하지만 앞서 언급했듯이, 모든 인덱스를 마구잡이로 붙인다는 것 또한 좋지는 않으므로 주의가 필요하다.



- 가이드 2) 인덱스 컬럼에 사용하는 연산자는 가급적 등등 연산자(=)를 사용하라.

  - 인덱스 컬럼을 WHERE 조건에 모두 명시하였더라도 LIKE 와 같은 연산자를 사용하면 인덱스 효율이 떨어질 수가 있습니다.

    - 이유) LIKE 표현의 스캔범위는 다음과 같습니다. 

      - 예시) SQL > .... WHERE COLUMN1 LIKE 'DIDI%' 라는 조건이 걸린 쿼리문에서 조회를 하게되면 스캔의 범위는

        DIDI 라는 문자가 일부분에 포함되면 스캔을 하게되는 기능을 합니다.

      - 결과) 따라서 INDEX RANGE 스캔의 차이 때문에 발생하게 되는 차이 이므로, 조절하여 쿼리문을 작성하는 것이 바람직합니다.


- 가이드 3) 인덱스 컬럼은 변형하여 사용하지 않도록 한다.

   - where 조건에 인덱스 컬럼을 사옹했고, 동등 연산자 = 를 사용했다 하더라고 인덱스 컬럼에 변형을 가하게 되면

    쿼리 실행시 인덱스를 거치지 못합니다.

	            *예시*
	            SELECT * 
	            FROM CONTRACT
	            WHERE SUBSTR(CONTACT_NO,1,1) = '9'
	            AND CONTRACT_REV = '1'
	
	            이 일반적인 쿼리문 이라고 가정하자.
	
	            컬럼에 변형을 가한 예시1)
	            SELECT * 
	            FROM CONTRACT			-- 만약, CREATOR_ID 특성이 UNIQUE 인덱스 라면
	            WHERE CREATOR_ID LIKE 'KKK%'   -- 인덱스 스캔시 단일 스캔이 아닌 인덱스 레인지 스캔이 일어나지만 = 보다는 느리게 쿼리가 실행될 것임.			   (like 는 부분적으로 일치하는 칼럼을 찾을때 쓰는것이기 때문.)
	
	            컬럼에 변형을 가한 예시2)
	            SELECT * 
	            FROM CONTRACT
	            WHERE SUBSTR(CREATOR_ID,1,3) = 'KKK'   -- 컬럼 값에 변형을 주는 로직을 구사했기 때문에 인덱스 설정된 스캔 범위에서 벗어남.
	                                  처음부터 끝까지 풀 스캔을 하기 때문에 N.N SEC 가 오래 걸릴 수 밖에 없다.



- 가이드 4) OR 보다는 AND 를 사용한다.
   - 옵티마이저의 OR 연산자는 OR 연산자로 연결된 쿼리를 UNION ALL 로 처리하는 과정이므로, AND 로 사용해야 쿼리를 보다 가볍게
        실행시킬 수 있습니다.

         - ![](C:\Users\quddb\Desktop\3주차 이미지\or and 쿼리문의 튜닝 성능비교1.PNG)
         - ![](C:\Users\quddb\Desktop\3주차 이미지\or and 쿼리문의 튜닝 성능비교2.PNG)
               - 위의 이미지는 OR 과 AND를 사용한 쿼리문의 Explain Analyse 결과를 나타낸 것입니다. 주석으로 기록한 것으로 보면 큰 차이가 나지는 않을 것으로 보이지만, OR을 사용한 쿼리문이 Seq Scan 부터 row 값들을 거쳐오는 개수가 압도적으로 많은 것을 확인할 수 있습니다.
               - 만일 이보다 훨씬 많은 데이터가 담긴 것을 조회한다고 생각하면 당연히 OR 로 수식한 쿼리가 저하가 될 것입니다.

        

- 가이드 5) 그룹 쿼리를 사용할 경우 HAVING 같은 절 보다는 WHERE 절에서 필터링을 먼저 한다.

  - 그룹핑 쿼리의 처리순서는 항상 WHERE 조건절이 먼저 처리가 되므로, WHERE 절에서 가급적 필터링을 먼저 처리하게 쿼리를 짜는게 좋습니다.
     - 이유) HAVING 절은 이미 WHERE 절에서 처리된 ROW 데이터들을 조건으로 검사를 하기 때문에 성능적인 면에서 저하된다고 합니다.

       

- 가이드 6) DISTINCT 함수는 가급적 사용하지 않는다.
   - 중복제거 함수인 이 키워드는 쿼리 내부적으로 정렬작업을 수반하는 함수이기 때문에 꼭 필요한 경우가 아니라면 사용하지 않는 것이 좋습니다.

      - ![](C:\Users\quddb\Desktop\3주차 이미지\distinct의 쿼리튜닝 측면 단점1.PNG)

      - ![](C:\Users\quddb\Desktop\3주차 이미지\distinct의 쿼리튜닝 측면 단점2.PNG)

         - distinct 함수가 없는 쿼리과 함수가 적용된 쿼리의 실행계획 및 실행 결과를 비교한 사진입니다. 아래쪽 쿼리인 distinct 함수가 

           있는 쿼리가 인덱스 스캔시 거치는 row 개수 그리고 actual, Planning, Execution time 모두 더 높게 나타났습니다.

           - 이유) distinct() 자체가 내부적으로 정렬 작업을 거친 뒤에 선별을 해주는 함수라고 합니다.

     

- 가이드 7 ) IN, NOT IN 대신 EXISTS 와 NOT EXISTS를 사용한다.
   - IN 이나 NOT IN 연산자 보다는 EXISTS 나 NOT EXISTS를 사용하는 것이 더 좋은 성능을 발휘합니다.

		*예시*
		IN 사용
		SELECT A.*
		FROM CONTRACT A, CONTRACTOR B
		WHERE A.CONTRACT_NO = B.CONTRACT_NO
		AND B.CONTRACT_NO('1111', '2222', '3333');
	
		EXISTS 사용
		SELECT *
		FROM CONTRACT A
		WHERE EXISTS (SELECT 1
				FROM CONTRACTOR B
				WHERE A.CONTRACT_NO = B.CONTRACT_NO
				AND B.CONTRACT_NO IN ('1111', '2222', '3333'));
	
		: 아래 예시의 쿼리가 서브쿼리를 포함하고 있어서 미관상 성능이 좋지 않을것 같지만,
		  실제로는 위의 쿼리보다 실행 비용이 더 적다. 데이터가 수만건 이상이 저장된 곳이라면 분명 아래의 쿼리가
		  성능면에서 눈에 띄게 좋은 차이를 보일 것이다.
		  이유)IN을 이용하게 되면 서브쿼리 전체를 먼저 스캔하고 table A의 모든 레코드에 대해
		      IN에서 추출된 데이터와 비교하게 되므로 서브쿼리의 추출되는 레코드가 많다면 성능이 저하된다.
			  EXISTS와 조인을 이용하는 방법은 비교해서 참 또는 거짓만 리턴하므로 서브쿼리의 추출되는 데이터가 많다면
			  훨씬 좋은 성능을 보이게 된다.

?		

- 가이드 8 ) SET 연산자 사용시 UNION 대신에 UNION ALL을 사용한다.
  - UNION 연산자는 연결된 쿼리에서 동일한 ROW는 제거하고 하나의 로우만 반환시키는 반면에 UNION ALL은 그렇지 않습니다.
    	- 원인) 따라서 추가적으로 필터링하는 로직이 숨어있으므로 UNION ALL 보다는 비용이 높을 수 밖에 없습니다.


	        쿼리 실행 비용이란? : 특정 하드웨어에서 쿼리의 실행 및 완료에 소요되는 시간이나 메모리 측정값들을 말한다.
	                 무거운 쿼리이거나 복잡하게 짜인 저효율 쿼리일수록 쿼리 실행시 시간이 많이들고 메모리 사용량이 늘어난다.
	                 이러한 쿼리들을 COST가 많이 소비되는 쿼리문 이라고 한다.



2)슬로우 쿼리 대처법 -- 로그 남겨서 기록보는 법은 집의 오라클로 진행하기.



###### 3)모니터링 쿼리란? 

 : 현재 사용하는 DB의 상태와 관련한 정보를 제공해주는 SQL문 입니다.

 : 지금부터 소개할 내용은 pg_ 가 접두어로 사용되는 컬럼이 많을 것입니다. 해당 함수들은 postgreSQL 9.6.2. 이상 버전부터 제공해주는

?	postgreSQL 의 라이브러리 기능입니다.

?	* https://postgresql.kr/docs/9.6/pgstatstatements.html 으로 가시면 해당 문서를 확인하실 수 있습니다.

?	* 모니터링 쿼리는 DB 별로 많이 상이하니 사용하시게 되면 해당하는 DB 별로 내용을 찾아보시면 될것 같습니다.



- 1.디스크를 제일 많이 잡아먹는 쿼리문들을 조회할 수 있는 SQL문

  - ![](C:\Users\quddb\Desktop\3주차 이미지\디스크 잡아먹는 쿼리 확인하기.PNG)

    - 위의 SQL문을 실행한 결과입니다. LIMIT 은  Postgre 기준이고 오라클은 where rownum 입니다.  query 컬럼에 해당하는 쿼리문들이

      해당 디스크의 용량을 잡아먹는 쿼리문으로 나타납니다.



- 2.long run 쿼리문을 출력할 수 있는 SQL문

  - ![](C:\Users\quddb\Desktop\3주차 이미지\롱런하는 쿼리문 확인하기.PNG)

    - SQL문을 조회한 결과중 age 라는 컬럼에 함수 query_start, timestamp() 함수를 넣어서 표현하였습니다. 

      시분초 밀리단위까지 보여주는 함수라고 합니다. 따라서 어느 쿼리가 실행 시간이 얼마나 되는가를 알 수 있습니다.



- 3.데이터베이스 사용량을 확인하는 SQL문
  - ![](C:\Users\quddb\Desktop\3주차 이미지\데이터베이스 사용량 확인.PNG)
    - 위의 SQL문을 실행한 결과로 datname 은 데이터베이스 이름을 나타내주고, size 는 해당 공간의 사용량을 나타내줍니다.



- 4.테이블스페이스 사용량을 확인하는 SQL문
  - ![](C:\Users\quddb\Desktop\3주차 이미지\테이블 스페이스 사이즈 보기.PNG)
    - 테이블 스페이스의 사용량 입니다. size_pretty로 표현하여 사용량을 확인할 수 있습니다.



- 5.테이블 사이즈를 확인하는 SQL문
  - ![](C:\Users\quddb\Desktop\3주차 이미지\테이블 사이즈 확인하기.PNG)
    - 해당 데이터베이스 안에 만들어진 테이블 이름, 사용량을 조회하는 쿼리문입니다.



- 6.실행시간 기준 가장 오래걸리는 쿼리를 확인하는 SQL문

  - ![](C:\Users\quddb\Desktop\3주차 이미지\실행시간 오래걸리는 리스트 조회문.PNG)

    - 실행시간을 나타내어 어느 쿼리가 실행이 오래 걸리는 것인지를 보여줍니다. 실행이 오래걸리면 그만큼 무겁거나, 혹은 

      개선이 필요한 쿼리일 수 있습니다. 튜닝을 하게되면 이런 쿼리들이 필요한 부분일 것입니다.

  
