### XP(eXtreme Programming)

xp는 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법

5가지 핵심가치 : 의용단피존(의사소통, 용기, 단순성, 피드백, 존중)

주요 실천방법 :

- Pair Programming(짝 프로그래밍)
- Collective Ownership(공동 소유 코드)
- Test-Driven Development(테스트 주도 개발)
- Whole Team(전체 팀)
- Continuous Integration(계속적인 통합)
- Refactoring(리팩토링) : 목적은 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발하도록 하기 위함
- Small Release(소규모 릴리즈)

### 요구사항 개발 프로세스

도출 → 분석 → 명세 → 확인

### 요구사항 분석

구조적 분석 기법 : 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법

주요 구조적 분석 기법 도구 : 자료흐름도(DFD), 자료 사전(DD), 소단위 명세서, 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서

자료 흐름도(DFD; Data Flow Diagram)

프로세스(Process), 자료흐름(Data Flow), 자료저장소(Data Store), 단말(Terminator)

자료 사전(DD; Data Dictionary)

= : 자료의 정의

+: 자료의 연결

( ) : 자료의 생략

[ ] : 자료의 선택 : 또는(or)

{ } : 자료의 반복

\*\* : 자료의 설명 : 주석

### 요구사항 분석용 CASE(자동화 도구)

요구사항을 자동으로 분석하고, 시스템/소프트웨어 설계를 위한 도구

**SADT** : 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구, SoftTech 사에서 개발, 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구

**SREM = RSL/REVS** : TRW 사가 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 도구, RSL/ REVS를 사용하는 자동화 도구

**PSL/ PSA** : PSL과 PSA를 사용하는 자동화 도구, 미시간 대학에서 개발

**TAGS** : 시스템 공학 방법 응용에 대한 자동 접근 방법, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구

### HIPO(Hierarchy Input Process Output)

시스템 실행 과정인 입력, 처리, 출력의 기능을 표현한 것

**Hipo Chart**의 종류 : 가시적 도표, 총체적 도표, 세부적 도표

### UML(Unified Modeling Language)

시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어

Rambaugh(OMT), Booch, Jacobson 등의 객체지행 방법론의 장점을 통합

OMG에서 표준으로 지정

## **UML 구성요소** : **사물**, **관계**, **다이어그램**

- **사물 :** 다이어그램 안에서 관계가 형성될 수 있는 대상들

  **_구조사물_** - 시스템의 개념적, 물리적 요소를 표현, 클래스, 유스케이스, 컴포넌트, 노드 등

  **_행동사물_** - 시간과 공간에 따른 요소들의 행위를 표현, 상호작용, 상태머신 등

  **_그룹사물_** - 요소들을 그룹으로 묶어서 표현

  **_주해사물_** - 부가적인 설명이나 제약조건 등을 표현, 노트

- **관계** : 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계, 실체화 관계

  집합관계 : 하나의 사물이 다른 사물에 포함되어 있는 관계

- **다이어그램** : 사물과 관계를 도형으로 표현한 것

  **구조적 다이어그램**의 종류 : **클래스** 다이어그램, **객체** 다이어그램, **컴포넌트** 다이어그램, **배치** 다이어그램, **복합체 구조** 다이어그램, **패키지** 다이어그램

  **객체 다이어그램** : 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현, 럼바우 객체지향 분석 기법에서 객체 모델링에 활용됨

  **배치 다이어그램** : 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현

  구현단계에서 사용되는 것 : 컴포넌트 다이어그램, 배치 다이어그램

  **행위 다이어그램**의 종류 : **유스케이스** 다이어그램, **시퀀스** 다이어그램, **커뮤니케이션** 다이어그램, **상태** 다이어그램, **활동** 다이어그램, **상호작용 개요** 다이어그램, **타이밍** 다이어그램

  **유스케이스 다이어그램** : 사용자의 요구를 분석하는 것으로, 기능모델링 작업에 사용함, 사용자(Actor),와 사용사례(Use Case)로 구성

  **시퀀스 다이어그램** : 상호작용하는 시스템이나 객체들이 주고받는 메시지를 표현

  **커뮤니케이션 다이어그램** : 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관관계를 표현

  **상태 다이어그램** : 하나의 객체가 자신이 속한 클래스의 상태변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지를 표현, 럼바우 객체지향 분석 기법에서 동적 모델링에 활용

  **활동 다이어그램** : 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현

  **상호작용 개요 다이어그램** : 상호작용 다이어그램 간의 제어 흐름을 표현

  **타이밍 다이어그램** : 객체 상태 변화와 시간 제약을 명시적으로 표현

**스테레오 타입** : **UML**에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것 `≪≫`겹화살괄호 사이에 표현할 형태를 기술

### 기능 모델링

사용자의 요구사항을 분석하여 **개발될 시스템이 갖춰야 할 기능**을 정리한 후 **사용자와** 함께 정리된 내용을 **공유하기 위해 그림으로 표현**하는 것

개발될 시스템의 전반적인 형태를 기능에 맞춰 표현한다.

종류 : 유스케이스 다이어그램, 액티비티 다이어그램

**유스케이스 다이어그램**

개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한것

구성요소 : 시스템/시스템 범위, 액터, 유스케이스, 관계

**시스템 / 시스템 범위**: 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현한 것

**액터** : 시스템과 상호작용을 하는 모든 외부 요소, 주로 사람이나 외부 시스템을 의미, -주액터 : 시스템을 사용함으로써 이득을 얻는 대상으로 주로, 사람이 해당 됨 -부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로 조직이나 기관 등이 될 수 있음`≪Actor≫`

**유스케이스** : 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능을 표현한 것, 타원형

**관계** : 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있음 -유스케이스에서 나타날 수 있는 관계 : 포함관계`≪include≫`, 확장관계`≪extends≫`, 일반화관계 -포함관계 : 두 개 이상의 유스케이스에 공통적으로 적용되는 기능을 별도로 분리하여 새로운 유스케이스로 만든경우, 원래의 유스케이스와 새롭게 분리된 유스케이스와의 관계를 포함관계라고 함 -확장관계 : 유스케이스가 특정 조건에 부합되어 유스케이스의 기능이 확장될 때 원래의 유스케이스와 확장된 유스케이스와의 관계를 확장관계라고 함
포함관계는 원래의 유스케이스에서 새롭게 포함되는 유스케이스 쪽으로 , 확장관계는 확장될 쪽에서 원래의 유스케이스쪽으로 점선 화살표 연결

**활동(Activity) 다이어그램**

사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것

하나의 유스케이스 안에서 혹은 유스케이스 사이에 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다

자료흐름도와 비슷하다

구성요소 : 액션/ 액티비티, 시작 노드, 종료노드, 조건(판단)노드, 병합노드, 포크(Fork)노드, 조인(Join)노드, 스윔레인(Swim Lane)

### 정적모델링

사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것
대표적 : 클래스 다이어그램

**클래스 다이어그램**

클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것, 시스템 구성요소를 문서화 하는데 사용한다

구성요소 : 클래스, 제약조건, 관계

- **클래스** : 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현한 것, 일반적으로 3개의 구획(Compartment)으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기함

  -속성: 클래스의 상태나 정보를 표현 -오퍼레이션 : 클래스가 수행할 수 있는 동작으로, 함수(메소드)라고도 함

- **제약조건** : 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적음
  클래스 안에 제약조건을 기술할 때는 중괄호 `{ }`를 이용함
- **관계** : 클래스와 클래스 사이의 연관성을 표현함, 연관관계, 집합관계, 포함 관계, 일반화 관계, 의존관계가 있음
- **연관클래스** : 연관관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스, 두 클래스의 연관관계를 나타내는 선의 가운데로부터 점선을 연관 클래스로 이어 표시한다.

### 동적 모델링

시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것이다.

시스템이 실행될 때 구성 요소들 간의 메시지 호출, 즉 오퍼레이션을 통한 상호 작용에 초점을 둔다.

종류 : 시퀀스 다이어그램, 커뮤니케이션 다이어그램, 상태 다이어그램

**시퀀스 다이어그램** : 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것, 각 동작에 참여하는 시스템이나 객체들의 수행 기간을 확인 할 수 있다.

구성요소 : 액터, 객체, 생명선, 실행상자, 메시지, 객체 소멸, 프레임

- **객체** : 메시지를 주고받는 주체
- **생명선** : 객체가 메모리에 존재하는 기간으로 객체 아래쪽에 점선을 그어 표현함, 객체소멸이 표시된 기간까지 존재함
- **실행상자** : 객체가 메시지를 주고받으며 구동되고 있음을 표현함
- **프레임** : 다이어그램의 전체 또는 일부를 묶어 표현 한 것

**커뮤니케이션 다이어그램** : 시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 연관을 그림을 표현 한 것

동작에 참여하는 객체들 사이의 관계를 파악하는 데 사용된다.

클래스 다이어그램에서 관계가 제대로 표현됐는지 점검하는 용도로도 사용된다.

초기에는 협업 다이어그램이라고 불렸다

구성요소 : 액터, 객체, 링크, 메시지

**상태 다이어그램** : 객체들 사이에 발생하는 이벤트에 의한 객체들의 상태변화를 그림으로 표현한 것

객체의 상태란 객체가 갖는 속성 값의 변화를 의미한다

특정객체가 어떤 이벤트에 의해 상태 변환 과정이 진행되는지 확인하는데 사용된다.

시스템에서 상태 변환 이벤트를 확인할 필요가 있는 객체만을 대상으로 한다.

구성요소 : 상태, 시작상태, 종료상태, 상태전환, 이벤트, 프레임

- **상태전환** : 상태 사이의 흐름, 변화를 화살표로 표현한 것
- **이벤트** : 상태에 변화를 주는 현상, 이벤트에는 조건, 외부신호, 시간의 흐름 등이 있음
- **프레임** : 상태 다이어그램의 범위를 표현한 것

**패키지 다이어그램** : 요소들을 그룹화한 패키지 간의 의존관계를 표현한 것, 패키지는 또 다른 패키지의 요소가 될 수 있다,

대규모 시스템에서 주요 요소 간의 종속성을 파악하는 데 사용

구성요소 : 패키지, 객체, 의존관계

- **패키지** : 객체들을 그룹화 한 것

  -단순 표기법 : 패키지 안에 패키지 이름만 표현

  -확장 표기법 : 패키지 안에 요소까지 표현

- **객체** : 유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함도리 수 있는 다양한 요소들
- **의존 관계** : 패키지와 패키지, 패키지와 객체 간을 점선 화살표로 연결하여 표현함

  스테레오타입을 이용해 의존 관계를 구체적으로 표현할 수 있음. 의존 관계의 표현 형태는 사용자가 임의로 작성할 수 있으며, 대표적으로 import, access 가 사용됨

  -`≪import≫` : 패키지에 포함된 객체들을 직접 가져와서 이용하는 관계

  -`≪access≫` : 인터페이스를 통해 패키지 내의 객체에 접근하여 이용하는 관계

### 소프트웨어 개발 방법론

소프트웨어 개발, 유지보수 등에 필요한 여러가지 일들의 수행방법과 이러한 일들을 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화 한 것

목적 : 소프트웨어 생산성과 품질 향상

주요 소프트웨어 개발 방법론 : 구조적 방법론, 정보공학 방법론, 객체지향 방법론, 컴포넌트 기반(CBD) 방법론, 제품 계열 방법론, 애자일 방법론

**구조적 방법론** : 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론, 1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법론

쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적

복잡한 문제를 다루기 위해 분할과 정복 원리를 적용

개발 절차 : 타당성 검토 단계 → 계획 단계 → 요구사항 단계 → 설계 단계 → 구현 단계 → 시험 단계 → 운용/ 유지보수 단계

**정보공학 방법론** : 계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 자료 중심의 방법론

정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합

개발절차 : 정보 전략 계획 수립 단계 → 업무 영역 분석 단계 → 업무 시스템 설계 단계 → 업무 시스템 구축 단계

**객체지향 방법론** : 현실세계의 개체(Entity)를 객체로 만들어, 객체를 조립해서 필요한 소프트웨어를 구현하는 방법론

구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택됨

구성요소 : 객체, 클래스, 메시지 등

기본 원칙 : 캡슐화, 정보은닉, 추상화, 상속성, 다형성 등

개발 절차 : 요구 분석 단계 → 설계 단계 → 구현 단계 → 테스트 및 검증 단계 → 인도 단계

**컴포넌트 기반(CBD) 방법론** : 컴포넌트를 조합하여 새로운 애플리케이션을 만드는 방법론

컴포넌트의 재사용이 가능하여 시간과 노력을 절감할 수 있다

새로운 기능을 추가하는 것이 간단하여 확장성이 보장된다.

유지보수 비용을 최소화하고 생산성 및 품질을 향상 시킬 수 있다.

개발 절차 : 개발 준비 단계 → 분석 단계 → 설계 단계 → 구현 단계 → 테스트 단계 → 전개 단계 → 인도 단계

**제품 계열 방법론** : 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론

임베디드 소프트웨어를 만드는데 적합 \*임베디드 소프트웨어 : 디지털TV, 전기밥솥, 냉장고 등 해당 제품의 특정 기능에 맞게 특화되어서 제품 자체에 포함된 소프트웨어를 말함

제품계열 방법론은 영역공학과 응용공학으로 구분됨

- **영역공학** : 영역 분석, 영역설계, 핵심 자산을 구현하는 영역
- **응용공학** : 제품 요구 분석, 제품 설계, 제품을 구현하는 영역

영역공학과 응용공학의 연계를 위해 제품의 요구사항, 아키텍처, 조립 생산이 필요함

### S/W 공학의 발전적 추세

**소프트웨어 재사용** : 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것이다.

소프트웨어 재사용 방법 : 합성 중심, 생성 중심

- **합성 중심** : 전자칩 과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법으로, 블록 구성 방법이라고도 함
- **생성 중심** : 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법으로, 패턴 구성 방법이라고도 함

**소프트웨어 재공학** : 기존시스템을 이용하여 보다나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것이다.

### CASE(Computer Aided Software Engineering)

소프트웨어 개발과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것

- 주요기능 : 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원

### 비용 산정 기법

소프트웨어 비용 산정

소프트웨어 비용 결정 요소 : 프로젝트 요소, 자원 요소, 생산성 요소

- **프로젝트 요소** :

  - 제품 복잡도 : 소프트웨어 종류에 따라 발생할 수 있는 문제점들의 난이도
  - 시스템 크기 : 소프트웨어의 규모에 따라 개발해야 할 시스템의 크기
  - 요구되는 신뢰도 : 일정 기간 내 주어진 조건하에서 프로그램이 필요한 기능을 수행하는 정도

- **자원요소 :**
- 인적자원, 하드웨어 자원, 소프트웨어 자원
- **생산성 요소 :**
- 개발자 능력, 개발 기간

**하향식** : 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용산정

- **전문가 감정 기법** : 경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰
- **델파이 기법** : 전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법

**상향식** : 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정

- **LOC(원시코드라인 수) 기법** : 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법
- **개발 단계별 인월수 기법** : 기능을 구현시키는데 필요한 노력을 생명 주기의 각 단계별로 산정
- **수학적 산정 기법 :** 경험적 추정 모형, 실험적 추정 모형이라고도 한다.
- COCOMO 모형
- Putnam 모형
- 기능 점수(FP)모형

**COCOMO(COnstructor COst Model) 모형**

COCOMO 모형은 LOC(원시코드 라인 수 )에 의한 비용 산정 기법. 보헴이 제안

COCOMO의 소프트웨어 개발 유형 : 조직형, 반분리형, 내장형

- **조직형** : 5만라인 이하
- **반분리형** : 30만 라인 이하
- **내장형** : 30만 라인 이상

COCOMO 모형의 종류 : 기본형 COCOMO, 중간형 COCOMO, 발전형 COCOMO

- **기본형** : 소프트웨어의 크기와 개발 유형만을 이용해 비용 산정
- **중간형** : 4가지 특성에 의해 비용을 산정
- 제품의 특성, 컴퓨터의 특성, 개발 요원의 특성, 프로젝트 특성
- **발전형** : 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용산정, 소프트웨어 환경과 구성 요소가 사전에 정의되어 있어야 하며, 개발 과정의 후반부에 주로 적용

**Putnam 모형** : 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형,

Rayleigh-Norden 곡선의 노력분포도를 기초로 함

개발 기간이 늘어날수록 프로젝트 적용 인원의 노력 감소

**기능점수(FP; Function Point)모형**

소프트웨어의 기능을 증대시키는 요인별로 기능점수를 구한 후 비용을 산정하는 방식,

알브레히트가 제안

비용 산정 자동화 추정도구 : SLIM, ESTIMACS

**SLIM** : Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구

**ESTIMACS** : FP모형을 기초로 하여 개발된 자동화 추정 도구

프로젝트 일정 계획

프로젝트 일정 계획에 사용되는 기능 : WBS, PERT/CPM, 간트 차트 등

- **PERT** : 전체 작업의 상호 관계를 표시하는 네트워크,
  개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용한다.
- **CPM(임계 경로 기법)** : 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법
- **간트차트** : 프로젝트의 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표
  중간목표 미달성 시 그 이유와 기간을 예측할 수 있게 함,
  사용자와의 문제점이나 예산의 초과지출 등도 관리, 자원 배치와 인원 계획에 유용
